diff --git a/drivers/base/Kconfig b/drivers/base/Kconfig
index 064eb52ff7e2..5a89788472ea 100644
--- a/drivers/base/Kconfig
+++ b/drivers/base/Kconfig
@@ -105,6 +105,7 @@ source "drivers/base/firmware_loader/Kconfig"
 
 config WANT_DEV_COREDUMP
 	bool
+	default y
 	help
 	  Drivers should "select" this option if they desire to use the
 	  device coredump mechanism.
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index 89b512905be1..fd6402036a55 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -196,6 +196,10 @@ static const struct mmc_fixup __maybe_unused sdio_card_init_methods[] = {
 			      MMC_QUIRK_BROKEN_BYTE_MODE_512 |
 			      MMC_QUIRK_LENIENT_FN0 |
 			      MMC_QUIRK_BLKSZ_FOR_BYTE_MODE),
+	
+	SDIO_FIXUP_COMPATIBLE("morse,mm6104", add_quirk, MMC_QUIRK_NO_18V),
+
+	SDIO_FIXUP_COMPATIBLE("morse,mm610x", add_quirk, MMC_QUIRK_NO_18V),
 
 	END_FIXUP
 };
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4b19b8a16b09..cf893f6908f2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -739,7 +739,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * try to init uhs card. sdio_read_cccr will take over this task
 	 * to make sure which speed mode should work.
 	 */
-	if (rocr & ocr & R4_18V_PRESENT) {
+	if ((rocr & ocr & R4_18V_PRESENT)  && !(card->quirks & MMC_QUIRK_NO_18V)) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
 			mmc_sdio_pre_init(host, ocr_card, card);
diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
index cc1fe0555e19..db9e3b78dbcd 100644
--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c
+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
@@ -396,7 +396,7 @@ static const struct gpio_chip bcm2835_gpio_chip = {
 	.get = bcm2835_gpio_get,
 	.set = bcm2835_gpio_set,
 	.set_config = gpiochip_generic_config,
-	.base = -1,
+	.base = 0,
 	.ngpio = BCM2835_NUM_GPIOS,
 	.can_sleep = false,
 	.add_pin_ranges = bcm2835_add_pin_ranges_fallback,
@@ -413,7 +413,7 @@ static const struct gpio_chip bcm2711_gpio_chip = {
 	.get = bcm2835_gpio_get,
 	.set = bcm2835_gpio_set,
 	.set_config = gpiochip_generic_config,
-	.base = -1,
+	.base = 0,
 	.ngpio = BCM2711_NUM_GPIOS,
 	.can_sleep = false,
 	.add_pin_ranges = bcm2835_add_pin_ranges_fallback,
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0f3e6e2c2474..518c268ed77d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1066,7 +1066,11 @@ static void spi_toggle_csgpiod(struct spi_device *spi, u8 idx, bool enable, bool
 		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx), !enable);
 	else
 		/* Polarity handled by GPIO library */
-		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx), activate);
+		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx),
+					 (spi->controller->flags &
+					  SPI_CONTROLLER_ENABLE_CS_GPIOD) ?
+						enable :
+						activate);
 
 	if (activate)
 		spi_delay_exec(&spi->cs_setup, NULL);
@@ -3923,6 +3927,15 @@ int spi_setup(struct spi_device *spi)
 			"setup: MOSI configured to idle low and high at the same time.\n");
 		return -EINVAL;
 	}
+
+	if (ctlr->use_gpio_descriptors && ctlr->cs_gpiods &&
+	    ctlr->cs_gpiods[spi->chip_select[0]] && !(spi->mode & SPI_CS_HIGH) &&
+	    !(ctlr->flags & SPI_CONTROLLER_ENABLE_CS_GPIOD)) {
+		dev_dbg(&spi->dev,
+			"setup: forcing CS_HIGH (use_gpio_descriptors)\n");
+		spi->mode |= SPI_CS_HIGH;
+	}
+
 	/*
 	 * Help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current controller.
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index d07c1f0ad3de..c638eb382eea 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -4289,6 +4289,9 @@ enum ieee80211_back_actioncode {
 	WLAN_ACTION_ADDBA_REQ = 0,
 	WLAN_ACTION_ADDBA_RESP = 1,
 	WLAN_ACTION_DELBA = 2,
+	WLAN_ACTION_NDP_ADDBA_REQ = 128,
+	WLAN_ACTION_NDP_ADDBA_RESP = 129,
+	WLAN_ACTION_NDP_DELBA = 130,
 };
 
 /* BACK (block-ack) parties */
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index eb67d3d5ff5b..bbe2bb77ef08 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -295,6 +295,9 @@ struct mmc_card {
 #define MMC_QUIRK_BROKEN_SD_CACHE	(1<<15)	/* Disable broken SD cache support */
 #define MMC_QUIRK_BROKEN_CACHE_FLUSH	(1<<16)	/* Don't flush cache until the write has occurred */
 #define MMC_QUIRK_BROKEN_SD_POWEROFF_NOTIFY	(1<<17) /* Disable broken SD poweroff notify support */
+#define MMC_QUIRK_NO_18V   (1<<18)     /* Ignore voltage negotiation and don't use 1.8v */
+#define MMC_QUIRK_WORKING_SD_CQ	(1<<30)		/* SD card has known-good CQ implementation */
+#define MMC_QUIRK_ERASE_BROKEN	(1<<31)		/* Skip erase */
 
 	bool			written_flag;	/* Indicates eMMC has been written since power on */
 	bool			reenable_cmdq;	/* Re-enable Command Queue */
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 71ad766932d3..f3a3be6d1b82 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -596,6 +596,13 @@ struct spi_controller {
 	 */
 #define SPI_CONTROLLER_MULTI_CS		BIT(7)
 
+/*
+ * When this flag is set:
+ * 1. Do not set SPI_CS_HIGH by default during setup.
+ * 2. Invert GPIO polarity in the spi_set_cs function when SPI mode is set to SPI_CS_HIGH.
+ */
+#define SPI_CONTROLLER_ENABLE_CS_GPIOD BIT(9)
+
 	/* Flag indicating if the allocation of this struct is devres-managed */
 	bool			devm_allocated;
 
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 8a712ca73f2b..40f2727ef866 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -127,6 +127,8 @@ struct wiphy;
  *	even if it is otherwise disabled.
  * @IEEE80211_CHAN_ALLOW_6GHZ_VLP_AP: Allow using this channel for AP operation
  *	with very low power (VLP), even if otherwise set to NO_IR.
+ * @IEEE80211_CHAN_IGNORE: Mark this channel as disabled when
+ *	communicating channel list via nl80211.
  * @IEEE80211_CHAN_ALLOW_20MHZ_ACTIVITY: Allow activity on a 20 MHz channel,
  *	even if otherwise set to NO_IR.
  */
@@ -158,6 +160,7 @@ enum ieee80211_channel_flags {
 	IEEE80211_CHAN_CAN_MONITOR		= BIT(24),
 	IEEE80211_CHAN_ALLOW_6GHZ_VLP_AP	= BIT(25),
 	IEEE80211_CHAN_ALLOW_20MHZ_ACTIVITY     = BIT(26),
+	IEEE80211_CHAN_IGNORE			= BIT(27),
 };
 
 #define IEEE80211_CHAN_NO_HT40 \
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index fee854892bec..cdd444871131 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -127,6 +127,14 @@
  * via the usual ieee80211_tx_dequeue).
  */
 
+/** Morse Micro patches which add functionality that the driver needs to know about, can be
+ * signalled by adding a define here.
+ */
+
+/** mac80211 has the capability to negotiate NDP block acknowledgements */
+#define MORSE_MAC80211_S1G_FEATURE_NDP_BLOCKACK
+
+
 /**
  * DOC: HW timestamping
  *
@@ -2826,6 +2834,9 @@ struct ieee80211_txq {
  *	implements MLO, so operation can continue on other links when one
  *	link is switching.
  *
+ * @IEEE80211_HW_SUPPORTS_NDP_BLOCKACK: Hardware supports 11ah A-MPDU aggregation with NDP block
+ *	ACKs
+ *
  * @IEEE80211_HW_STRICT: strictly enforce certain things mandated by the spec
  *	but otherwise ignored/worked around for interoperability. This is a
  *	HW flag so drivers can opt in according to their own control, e.g. in
@@ -2890,6 +2901,7 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_DISALLOW_PUNCTURING,
 	IEEE80211_HW_DISALLOW_PUNCTURING_5GHZ,
 	IEEE80211_HW_HANDLES_QUIET_CSA,
+	IEEE80211_HW_SUPPORTS_NDP_BLOCKACK,
 	IEEE80211_HW_STRICT,
 
 	/* keep last, obviously */
@@ -3713,6 +3725,7 @@ enum ieee80211_ampdu_mlme_action {
  *	%IEEE80211_AMPDU_TX_OPERATIONAL
  * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.
  *	valid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL
+ * @ndp: indicates the driver has requested the session to use NDP block ACKs
  * @timeout: BA session timeout. Valid only when the action is set to
  *	%IEEE80211_AMPDU_RX_START
  */
@@ -3723,6 +3736,7 @@ struct ieee80211_ampdu_params {
 	u16 ssn;
 	u16 buf_size;
 	bool amsdu;
+	bool ndp;
 	u16 timeout;
 };
 
diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c
index fe7eab4b681b..38833ae28ab4 100644
--- a/net/mac80211/agg-rx.c
+++ b/net/mac80211/agg-rx.c
@@ -80,6 +80,8 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	RCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);
 	__clear_bit(tid, sta->ampdu_mlme.agg_session_valid);
 
+	params.ndp = tid_rx ? tid_rx->ndp : false;
+
 	ht_dbg(sta->sdata,
 	       "Rx BA session stop requested for %pM tid %u %s reason: %d\n",
 	       sta->sta.addr, tid,
@@ -94,7 +96,7 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	/* check if this is a self generated aggregation halt */
 	if (initiator == WLAN_BACK_RECIPIENT && tx)
 		ieee80211_send_delba(sta->sdata, sta->sta.addr,
-				     tid, WLAN_BACK_RECIPIENT, reason);
+				     tid, params.ndp, WLAN_BACK_RECIPIENT, reason);
 
 	/*
 	 * return here in case tid_rx is not assigned - which will happen if
@@ -190,7 +192,7 @@ static void ieee80211_add_addbaext(struct ieee80211_sub_if_data *sdata,
 
 static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 				      u8 dialog_token, u16 status, u16 policy,
-				      u16 buf_size, u16 timeout,
+				      u16 buf_size, u16 timeout, bool ndp,
 				      const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -211,7 +213,8 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;
+	mgmt->u.action.u.addba_resp.action_code = ndp ?
+			WLAN_ACTION_NDP_ADDBA_RESP : WLAN_ACTION_ADDBA_RESP;
 	mgmt->u.action.u.addba_resp.dialog_token = dialog_token;
 
 	capab = u16_encode_bits(amsdu, IEEE80211_ADDBA_PARAM_AMSDU_MASK);
@@ -232,7 +235,7 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 				     u8 dialog_token, u16 timeout,
 				     u16 start_seq_num, u16 ba_policy, u16 tid,
-				     u16 buf_size, bool tx, bool auto_seq,
+				     u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				     const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_local *local = sta->sdata->local;
@@ -243,6 +246,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 		.tid = tid,
 		.amsdu = false,
 		.timeout = timeout,
+		.ndp = ndp,
 		.ssn = start_seq_num,
 	};
 	int i, ret = -EOPNOTSUPP;
@@ -267,6 +271,11 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 		goto end;
 	}
 
+	if (ndp && !ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK)) {
+		ht_dbg(sta->sdata, "Requested NDP BA but HW does not support it\n");
+		goto end;
+	}
+
 	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
 		ht_dbg(sta->sdata,
 		       "Suspend in progress - Denying ADDBA request (%pM tid %d)\n",
@@ -398,6 +407,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 	tid_agg_rx->started = false;
 	tid_agg_rx->reorder_buf_filtered = 0;
 	tid_agg_rx->tid = tid;
+	tid_agg_rx->ndp = params.ndp;
 	tid_agg_rx->sta = sta;
 	status = WLAN_STATUS_SUCCESS;
 
@@ -419,7 +429,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 	if (tx)
 		ieee80211_send_addba_resp(sta, sta->sta.addr, tid,
 					  dialog_token, status, 1, buf_size,
-					  timeout, addbaext);
+					  timeout, params.ndp, addbaext);
 }
 
 void ieee80211_process_addba_request(struct ieee80211_local *local,
@@ -431,6 +441,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	struct ieee802_11_elems *elems = NULL;
 	u8 dialog_token;
 	int ies_len;
+	bool ndp_ba;
 
 	/* extract session parameters from addba request frame */
 	dialog_token = mgmt->u.action.u.addba_req.dialog_token;
@@ -442,6 +453,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	ba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;
 	tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
 	buf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;
+	ndp_ba = (mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_NDP_ADDBA_REQ);
 
 	ies_len = len - offsetof(struct ieee80211_mgmt,
 				 u.action.u.addba_req.variable);
@@ -461,7 +473,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 
 	__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,
 					start_seq_num, ba_policy, tid,
-					buf_size, true, false,
+					buf_size, true, false, ndp_ba,
 					elems ? elems->addba_ext_ie : NULL);
 free:
 	kfree(elems);
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index 1c18b862ef8c..e8b69af85e25 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -59,7 +59,7 @@
  */
 
 static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
-					 const u8 *da, u16 tid,
+					 const u8 *da, u16 tid, bool ndp,
 					 u8 dialog_token, u16 start_seq_num,
 					 u16 agg_size, u16 timeout)
 {
@@ -79,7 +79,8 @@ static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;
+	mgmt->u.action.u.addba_req.action_code = ndp ? WLAN_ACTION_NDP_ADDBA_REQ :
+			WLAN_ACTION_ADDBA_REQ;
 
 	mgmt->u.action.u.addba_req.dialog_token = dialog_token;
 	capab = IEEE80211_ADDBA_PARAM_AMSDU_MASK;
@@ -327,6 +328,8 @@ int __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
 		return -ENOENT;
 	}
 
+	params.ndp = tid_tx->ndp;
+
 	/*
 	 * if we're already stopping ignore any new requests to stop
 	 * unless we're destroying it in which case notify the driver
@@ -473,7 +476,7 @@ static void ieee80211_send_addba_with_timeout(struct sta_info *sta,
 	}
 
 	/* send AddBA request */
-	ieee80211_send_addba_request(sdata, sta->sta.addr, tid,
+	ieee80211_send_addba_request(sdata, sta->sta.addr, tid, tid_tx->ndp,
 				     tid_tx->dialog_token, tid_tx->ssn,
 				     buf_size, tid_tx->timeout);
 
@@ -491,10 +494,18 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 		.tid = tid,
 		.buf_size = 0,
 		.amsdu = false,
+		.ndp = false,
 		.timeout = 0,
 	};
 	int ret;
 
+	/* If the HW supports NDP blockacks, try to negotiate. It's the drivers responsibility to
+	 * clear .ndp if the conditions for NDP block acks are not met for this TID.
+	 * TODO: remove driver responsibility when S1G STA caps exist in mac80211
+	 */
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK))
+		params.ndp = true;
+
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 
 	/*
@@ -514,7 +525,11 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 
 	params.ssn = sta->tid_seq[tid] >> 4;
 	ret = drv_ampdu_action(local, sdata, &params);
+
+	/* driver may clear this flag if it does not want NDP for this session */
+	tid_tx->ndp = params.ndp;
 	tid_tx->ssn = params.ssn;
+
 	if (ret == IEEE80211_AMPDU_TX_START_DELAY_ADDBA) {
 		return;
 	} else if (ret == IEEE80211_AMPDU_TX_START_IMMEDIATE) {
@@ -754,6 +769,7 @@ static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 	params.buf_size = tid_tx->buf_size;
 	params.amsdu = tid_tx->amsdu;
+	params.ndp = tid_tx->ndp;
 
 	ht_dbg(sta->sdata, "Aggregation is on for %pM tid %d\n",
 	       sta->sta.addr, tid);
@@ -927,7 +943,7 @@ void ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,
 		ieee80211_agg_start_txq(sta, tid, false);
 
 	if (send_delba)
-		ieee80211_send_delba(sdata, sta->sta.addr, tid,
+		ieee80211_send_delba(sdata, sta->sta.addr, tid, tid_tx->ndp,
 			WLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);
 }
 
@@ -986,6 +1002,13 @@ void ieee80211_process_addba_resp(struct ieee80211_local *local,
 		return;
 	}
 
+	if ((tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_NDP_ADDBA_RESP) ||
+	    (!tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_ADDBA_RESP)) {
+		ht_dbg(sta->sdata, "wrong addBA response action code, %d ndp %d\n",
+				mgmt->u.action.u.addba_resp.action_code, tid_tx->ndp);
+		return;
+	}
+
 	del_timer_sync(&tid_tx->addba_resp_timer);
 
 	ht_dbg(sta->sdata, "switched off addBA timer for %pM tid %d\n",
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f11fd360b422..22fd7188ddf8 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -2127,6 +2127,10 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 		return err;
 	}
 
+	if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		mesh_update_mfp_flag(sdata,sta);
+	}
+
 	/*
 	 * for TDLS and for unassociated station, rate control should be
 	 * initialized only when rates are known and station is marked
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index a0710ae0e7a4..1ff676be47f6 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -499,6 +499,7 @@ static const char *hw_flag_names[] = {
 	FLAG(DISALLOW_PUNCTURING),
 	FLAG(DISALLOW_PUNCTURING_5GHZ),
 	FLAG(HANDLES_QUIET_CSA),
+	FLAG(SUPPORTS_NDP_BLOCKACK),
 	FLAG(STRICT),
 #undef FLAG
 };
diff --git a/net/mac80211/ht.c b/net/mac80211/ht.c
index 1c2b7dd8976a..de424fe3690e 100644
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@ -379,7 +379,7 @@ void ieee80211_ba_session_work(struct wiphy *wiphy, struct wiphy_work *work)
 				       sta->ampdu_mlme.tid_rx_manage_offl))
 			__ieee80211_start_rx_ba_session(sta, 0, 0, 0, 1, tid,
 							IEEE80211_MAX_AMPDU_BUF_HT,
-							false, true, NULL);
+							false, true, false, NULL);
 
 		if (test_and_clear_bit(tid + IEEE80211_NUM_TIDS,
 				       sta->ampdu_mlme.tid_rx_manage_offl))
@@ -454,7 +454,7 @@ void ieee80211_ba_session_work(struct wiphy *wiphy, struct wiphy_work *work)
 }
 
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code)
 {
 	struct ieee80211_local *local = sdata->local;
@@ -472,7 +472,7 @@ void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;
+	mgmt->u.action.u.delba.action_code = ndp ? WLAN_ACTION_NDP_DELBA : WLAN_ACTION_DELBA;
 	params = (u16)(initiator << 11); 	/* bit 11 initiator */
 	params |= (u16)(tid << 12); 		/* bit 15:12 TID number */
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index bfe0514efca3..251d7d1e6812 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -798,6 +798,10 @@ struct ieee80211_if_mesh {
 	int mesh_paths_generation;
 	int mpp_paths_generation;
 	struct mesh_tx_cache tx_cache;
+	 enum {
+		IEEE80211_MESH_MFP_DISABLED,
+		IEEE80211_MESH_MFP_ENABLED,
+	} mfp; /* management frame protection */
 };
 
 #ifdef CONFIG_MAC80211_MESH
@@ -2108,7 +2112,7 @@ bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
 				       const struct ieee80211_ht_cap *ht_cap_ie,
 				       struct link_sta_info *link_sta);
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code);
 int ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
 			       enum ieee80211_smps_mode smps, const u8 *da,
@@ -2121,7 +2125,7 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 				     u8 dialog_token, u16 timeout,
 				     u16 start_seq_num, u16 ba_policy, u16 tid,
-				     u16 buf_size, bool tx, bool auto_seq,
+				     u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				     const struct ieee80211_addba_ext_ie *addbaext);
 void ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,
 					 enum ieee80211_agg_stop_reason reason);
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 7e1e561ef76c..0b98addfcdaa 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1495,14 +1495,17 @@ static void ieee80211_iface_process_skb(struct ieee80211_local *local,
 		if (sta) {
 			switch (mgmt->u.action.u.addba_req.action_code) {
 			case WLAN_ACTION_ADDBA_REQ:
+			case WLAN_ACTION_NDP_ADDBA_REQ:
 				ieee80211_process_addba_request(local, sta,
 								mgmt, len);
 				break;
 			case WLAN_ACTION_ADDBA_RESP:
+			case WLAN_ACTION_NDP_ADDBA_RESP:
 				ieee80211_process_addba_resp(local, sta,
 							     mgmt, len);
 				break;
 			case WLAN_ACTION_DELBA:
+			case WLAN_ACTION_NDP_DELBA:
 				ieee80211_process_delba(sdata, sta,
 							mgmt, len);
 				break;
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 50eb1d8cd43d..73a1650417f2 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -1710,6 +1710,19 @@ void ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
 	}
 }
 
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	if (test_sta_flag(sta, WLAN_STA_MFP))
+	{
+		mpl_dbg(sdata,"%s: Mesh MFP Enabled\n",__func__);
+		ifmsh->mfp = IEEE80211_MESH_MFP_ENABLED;
+	} else {
+		mpl_dbg(sdata,"%s: Mesh MFP Disabled\n",__func__);
+		ifmsh->mfp = IEEE80211_MESH_MFP_DISABLED;
+	}
+}
+
 static void mesh_bss_info_changed(struct ieee80211_sub_if_data *sdata)
 {
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
diff --git a/net/mac80211/mesh.h b/net/mac80211/mesh.h
index 3f9664e4e00c..2350bf695dbb 100644
--- a/net/mac80211/mesh.h
+++ b/net/mac80211/mesh.h
@@ -418,12 +418,15 @@ static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata);
 void mesh_sync_adjust_tsf(struct ieee80211_sub_if_data *sdata);
 void ieee80211s_stop(void);
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta);
 #else
 static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 { return false; }
 static inline void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)
 {}
 static inline void ieee80211s_stop(void) {}
+static inline void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{}
 #endif
 
 #endif /* IEEE80211S_H */
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index 2922a9fec950..0ce7d970e509 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -190,6 +190,8 @@ static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
 		pos += 4;
 	}
 
+	if (sdata->u.mesh.mfp == IEEE80211_MESH_MFP_DISABLED)
+		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
 	ieee80211_tx_skb(sdata, skb);
 	return 0;
 }
@@ -304,6 +306,17 @@ void ieee80211s_update_metric(struct ieee80211_local *local,
 
 	failed = !(txinfo->flags & IEEE80211_TX_STAT_ACK);
 
+	if (!ewma_mesh_fail_avg_read(&sta->mesh->fail_avg)) {
+		/* If the average value in mesh metrics calculation
+		 * has been rounded to 0 (success), this resets it to
+		 * the smallest nonzero value (similarly to the initialization)
+		 * to avoid a case where a single failure would result in
+		 * an average value that goes beyond the value
+		 * of 95 (Link Failure Threshold)
+		 */
+		ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
+	}
+
 	/* moving average, scaled to 100.
 	 * feed failure as 100 and success as 0
 	 */
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 16bb3db67eaa..9a8a03c9ac5e 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -71,6 +71,14 @@ module_param(beacon_loss_count, int, 0644);
 MODULE_PARM_DESC(beacon_loss_count,
 		 "Number of beacon intervals before we decide beacon was lost.");
 
+/*
+ * Number of beacon intervals to wait for a beacon at association.
+ */
+static int beacon_wait_count = 1;
+module_param(beacon_wait_count, int, 0644);
+MODULE_PARM_DESC(beacon_wait_count,
+		 "Number of beacon intervals to wait for a beacon at association.");
+
 /*
  * Time the connection can be idle before we probe
  * it to see if we can still talk to the AP.
@@ -2615,6 +2623,7 @@ ieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,
 	now = jiffies;
 	link->u.mgd.csa.time = now +
 			       TU_TO_JIFFIES((max_t(int, csa_ie.count, 1) - 1) *
+					     sdata->vif.bss_conf.dtim_period *
 					     link->conf->beacon_int);
 
 	if (ieee80211_vif_link_active(&sdata->vif, link->link_id) &&
@@ -9125,11 +9134,12 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 		if (!beacon_ies) {
 			/*
 			 * Wait up to one beacon interval ...
-			 * should this be more if we miss one?
+			 * Beacon periods to wait can be set via modparam
 			 */
 			sdata_info(sdata, "waiting for beacon from %pM\n",
 				   link->u.mgd.bssid);
-			assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
+			assoc_data->timeout = TU_TO_EXP_TIME(beacon_wait_count *
+				req->bss->beacon_interval);
 			assoc_data->timeout_started = true;
 			assoc_data->need_beacon = true;
 		}
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 8e1fbdd3bff1..3151e0a37fc0 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1374,7 +1374,7 @@ static void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx,
 		if (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&
 		    !test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 		goto dont_reorder;
@@ -3246,6 +3246,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 {
 	struct sk_buff *skb = rx->skb;
 	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
+	struct ieee80211_mgmt *back = (struct ieee80211_mgmt *)skb->data;
 	struct tid_ampdu_rx *tid_agg_rx;
 	u16 start_seq_num;
 	u16 tid;
@@ -3272,7 +3273,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 
 		if (!test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 
@@ -3678,16 +3679,19 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 
 		switch (mgmt->u.action.u.addba_req.action_code) {
 		case WLAN_ACTION_ADDBA_REQ:
+		case WLAN_ACTION_NDP_ADDBA_REQ:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_req)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_ADDBA_RESP:
+		case WLAN_ACTION_NDP_ADDBA_RESP:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_resp)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_DELBA:
+		case WLAN_ACTION_NDP_DELBA:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.delba)))
 				goto invalid;
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index 9195d5a2de0a..877d688891da 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -171,6 +171,7 @@ struct sta_info;
  * @bar_pending: BAR needs to be re-sent
  * @amsdu: support A-MSDU withing A-MDPU
  * @ssn: starting sequence number of the session
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -199,6 +200,7 @@ struct tid_ampdu_tx {
 	u16 failed_bar_ssn;
 	bool bar_pending;
 	bool amsdu;
+	bool ndp;
 	u8 tid;
 };
 
@@ -226,6 +228,7 @@ struct tid_ampdu_tx {
  *	and ssn.
  * @removed: this session is removed (but might have been found due to RCU)
  * @started: this session has started (head ssn or higher was received)
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -253,7 +256,8 @@ struct tid_ampdu_rx {
 	u8 tid;
 	u8 auto_seq:1,
 	   removed:1,
-	   started:1;
+	   started:1,
+	   ndp:1;
 };
 
 /**
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 0ff8b56f5807..6a7af4ee2426 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -4307,6 +4307,12 @@ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 		if (fast_tx &&
 		    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))
 			goto out;
+	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		/* For mesh interface, sta is determined in ieee80211_tx_prepare after building
+		 * mesh header. Update tx pacing shift here, otherwise it affects TCP throughput as
+		 * there won't be enough packets to aggregate.
+		 */
+		sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
 	}
 
 	/* the frame could be fragmented, software-encrypted, and other
@@ -5032,11 +5038,11 @@ static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,
 
 static u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)
 {
-	beacon->cntdwn_current_counter--;
-
 	/* the counter should never reach 0 */
 	WARN_ON_ONCE(!beacon->cntdwn_current_counter);
 
+	beacon->cntdwn_current_counter--;
+
 	return beacon->cntdwn_current_counter;
 }
 
@@ -5306,7 +5312,13 @@ ieee80211_beacon_get_ap(struct ieee80211_hw *hw,
 	u16 csa_off_base = 0;
 	int mbssid_len;
 
-	if (beacon->cntdwn_counter_offsets[0]) {
+	bool short_beacon = (vif->bss_conf.dtim_period > 1);
+
+	if (ap->ps.dtim_count > 0)
+		short_beacon = ((ap->ps.dtim_count-1) != 0);
+
+	 /* Do not count channel switch count for short beacons */
+	if (beacon->cntdwn_counter_offsets[0] && !short_beacon) {
 		if (!is_template)
 			ieee80211_beacon_update_cntdwn(vif, link->link_id);
 
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 1ce8fff2a28a..9304bd2f7f66 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1439,8 +1439,8 @@ void cfg80211_init_wdev(struct wireless_dev *wdev)
 	wdev->ps_timeout = -1;
 
 	if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
-	     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
+	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&
+        !wdev->use_4addr)
 		wdev->netdev->priv_flags |= IFF_DONT_BRIDGE;
 
 	INIT_WORK(&wdev->disconnect_wk, cfg80211_autodisconnect_wk);
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index c778ffa1c8ef..00dfa3d58c54 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1122,6 +1122,9 @@ static int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,
 	if ((chan->flags & IEEE80211_CHAN_DISABLED) &&
 	    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))
 		goto nla_put_failure;
+	if ((chan->flags & IEEE80211_CHAN_IGNORE) &&
+	    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))
+		goto nla_put_failure;
 	if (chan->flags & IEEE80211_CHAN_NO_IR) {
 		if (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))
 			goto nla_put_failure;
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 18585b1416c6..78b6bfa515f7 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -1230,7 +1230,6 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			fallthrough;
 		case NL80211_IFTYPE_OCB:
 		case NL80211_IFTYPE_P2P_CLIENT:
-		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
 		case NL80211_IFTYPE_P2P_GO:
