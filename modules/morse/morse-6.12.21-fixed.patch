diff --git a/drivers/base/Kconfig b/drivers/base/Kconfig
index 064eb52ff7e2..5a89788472ea 100644
--- a/drivers/base/Kconfig
+++ b/drivers/base/Kconfig
@@ -105,6 +105,7 @@ source "drivers/base/firmware_loader/Kconfig"
 
 config WANT_DEV_COREDUMP
 	bool
+	default y
 	help
 	  Drivers should "select" this option if they desire to use the
 	  device coredump mechanism.
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index 9f8f5e121bc3..e47b68c5bf8f 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -251,6 +251,10 @@ static const struct mmc_fixup __maybe_unused sdio_card_init_methods[] = {
 			      MMC_QUIRK_BROKEN_BYTE_MODE_512 |
 			      MMC_QUIRK_LENIENT_FN0 |
 			      MMC_QUIRK_BLKSZ_FOR_BYTE_MODE),
+	
+	SDIO_FIXUP_COMPATIBLE("morse,mm6104", add_quirk, MMC_QUIRK_NO_18V),
+
+	SDIO_FIXUP_COMPATIBLE("morse,mm610x", add_quirk, MMC_QUIRK_NO_18V),
 
 	END_FIXUP
 };
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 4b19b8a16b09..cf893f6908f2 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -739,7 +739,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	 * try to init uhs card. sdio_read_cccr will take over this task
 	 * to make sure which speed mode should work.
 	 */
-	if (rocr & ocr & R4_18V_PRESENT) {
+	if ((rocr & ocr & R4_18V_PRESENT)  && !(card->quirks & MMC_QUIRK_NO_18V)) {
 		err = mmc_set_uhs_voltage(host, ocr_card);
 		if (err == -EAGAIN) {
 			mmc_sdio_pre_init(host, ocr_card, card);
diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
index 0414a1c96009..c84e24695970 100644
--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c
+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c
@@ -396,7 +396,7 @@ static const struct gpio_chip bcm2835_gpio_chip = {
 	.get = bcm2835_gpio_get,
 	.set = bcm2835_gpio_set,
 	.set_config = gpiochip_generic_config,
-	.base = -1,
+	.base = 0,
 	.ngpio = BCM2835_NUM_GPIOS,
 	.can_sleep = false,
 	.add_pin_ranges = bcm2835_add_pin_ranges_fallback,
@@ -413,7 +413,7 @@ static const struct gpio_chip bcm2711_gpio_chip = {
 	.get = bcm2835_gpio_get,
 	.set = bcm2835_gpio_set,
 	.set_config = gpiochip_generic_config,
-	.base = -1,
+	.base = 0,
 	.ngpio = BCM2711_NUM_GPIOS,
 	.can_sleep = false,
 	.add_pin_ranges = bcm2835_add_pin_ranges_fallback,
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6279bc713e69..8bd5b165bc0f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1066,7 +1066,11 @@ static void spi_toggle_csgpiod(struct spi_device *spi, u8 idx, bool enable, bool
 		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx), !enable);
 	else
 		/* Polarity handled by GPIO library */
-		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx), activate);
+		gpiod_set_value_cansleep(spi_get_csgpiod(spi, idx),
+					 (spi->controller->flags &
+					  SPI_CONTROLLER_ENABLE_CS_GPIOD) ?
+						enable :
+						activate);
 
 	if (activate)
 		spi_delay_exec(&spi->cs_setup, NULL);
@@ -3926,7 +3930,8 @@ int spi_setup(struct spi_device *spi)
 	}
 
 	if (ctlr->use_gpio_descriptors && ctlr->cs_gpiods &&
-	    ctlr->cs_gpiods[spi->chip_select[0]] && !(spi->mode & SPI_CS_HIGH)) {
+	    ctlr->cs_gpiods[spi->chip_select[0]] && !(spi->mode & SPI_CS_HIGH) &&
+	    !(ctlr->flags & SPI_CONTROLLER_ENABLE_CS_GPIOD)) {
 		dev_dbg(&spi->dev,
 			"setup: forcing CS_HIGH (use_gpio_descriptors)\n");
 		spi->mode |= SPI_CS_HIGH;
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 3750e56bfcbb..9a3bfd0ecdcb 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -4230,6 +4230,9 @@ enum ieee80211_back_actioncode {
 	WLAN_ACTION_ADDBA_REQ = 0,
 	WLAN_ACTION_ADDBA_RESP = 1,
 	WLAN_ACTION_DELBA = 2,
+	WLAN_ACTION_NDP_ADDBA_REQ = 128,
+	WLAN_ACTION_NDP_ADDBA_RESP = 129,
+	WLAN_ACTION_NDP_DELBA = 130,
 };
 
 /* BACK (block-ack) parties */
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6289155f806f..2dbe86e37dcd 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -295,6 +295,7 @@ struct mmc_card {
 #define MMC_QUIRK_BROKEN_SD_CACHE	(1<<15)	/* Disable broken SD cache support */
 #define MMC_QUIRK_BROKEN_CACHE_FLUSH	(1<<16)	/* Don't flush cache until the write has occurred */
 #define MMC_QUIRK_BROKEN_SD_POWEROFF_NOTIFY	(1<<17) /* Disable broken SD poweroff notify support */
+#define MMC_QUIRK_NO_18V   (1<<18)     /* Ignore voltage negotiation and don't use 1.8v */
 #define MMC_QUIRK_WORKING_SD_CQ	(1<<30)		/* SD card has known-good CQ implementation */
 #define MMC_QUIRK_ERASE_BROKEN	(1<<31)		/* Skip erase */
 
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 4b95663163e0..aa32c1a54d68 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -599,6 +599,13 @@ struct spi_controller {
 	 */
 #define SPI_CONTROLLER_MULTI_CS		BIT(7)
 
+/*
+ * When this flag is set:
+ * 1. Do not set SPI_CS_HIGH by default during setup.
+ * 2. Invert GPIO polarity in the spi_set_cs function when SPI mode is set to SPI_CS_HIGH.
+ */
+#define SPI_CONTROLLER_ENABLE_CS_GPIOD BIT(9)
+
 	/* Flag indicating if the allocation of this struct is devres-managed */
 	bool			devm_allocated;
 
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 941dc62f3027..dd0d1c5fd600 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -127,6 +127,8 @@ struct wiphy;
  *	even if it is otherwise disabled.
  * @IEEE80211_CHAN_ALLOW_6GHZ_VLP_AP: Allow using this channel for AP operation
  *	with very low power (VLP), even if otherwise set to NO_IR.
+ * @IEEE80211_CHAN_IGNORE: Mark this channel as disabled when
+ *	communicating channel list via nl80211.
  */
 enum ieee80211_channel_flags {
 	IEEE80211_CHAN_DISABLED			= BIT(0),
@@ -155,6 +157,7 @@ enum ieee80211_channel_flags {
 	IEEE80211_CHAN_NO_6GHZ_AFC_CLIENT	= BIT(23),
 	IEEE80211_CHAN_CAN_MONITOR		= BIT(24),
 	IEEE80211_CHAN_ALLOW_6GHZ_VLP_AP	= BIT(25),
+	IEEE80211_CHAN_IGNORE			= BIT(26),
 };
 
 #define IEEE80211_CHAN_NO_HT40 \
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 3b964f8834e7..d5c8e26b19e1 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -127,6 +127,14 @@
  * via the usual ieee80211_tx_dequeue).
  */
 
+/** Morse Micro patches which add functionality that the driver needs to know about, can be
+ * signalled by adding a define here.
+ */
+
+/** mac80211 has the capability to negotiate NDP block acknowledgements */
+#define MORSE_MAC80211_S1G_FEATURE_NDP_BLOCKACK
+
+
 /**
  * DOC: HW timestamping
  *
@@ -2826,6 +2834,9 @@ struct ieee80211_txq {
  *	implements MLO, so operation can continue on other links when one
  *	link is switching.
  *
+ * @IEEE80211_HW_SUPPORTS_NDP_BLOCKACK: Hardware supports 11ah A-MPDU aggregation with NDP block
+ *	ACKs
+ *
  * @IEEE80211_HW_STRICT: strictly enforce certain things mandated by the spec
  *	but otherwise ignored/worked around for interoperability. This is a
  *	HW flag so drivers can opt in according to their own control, e.g. in
@@ -2890,6 +2901,7 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_DISALLOW_PUNCTURING,
 	IEEE80211_HW_DISALLOW_PUNCTURING_5GHZ,
 	IEEE80211_HW_HANDLES_QUIET_CSA,
+	IEEE80211_HW_SUPPORTS_NDP_BLOCKACK,
 	IEEE80211_HW_STRICT,
 
 	/* keep last, obviously */
@@ -3713,6 +3725,7 @@ enum ieee80211_ampdu_mlme_action {
  *	%IEEE80211_AMPDU_TX_OPERATIONAL
  * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.
  *	valid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL
+ * @ndp: indicates the driver has requested the session to use NDP block ACKs
  * @timeout: BA session timeout. Valid only when the action is set to
  *	%IEEE80211_AMPDU_RX_START
  */
@@ -3723,6 +3736,7 @@ struct ieee80211_ampdu_params {
 	u16 ssn;
 	u16 buf_size;
 	bool amsdu;
+	bool ndp;
 	u16 timeout;
 };
 
diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c
index fe7eab4b681b..38833ae28ab4 100644
--- a/net/mac80211/agg-rx.c
+++ b/net/mac80211/agg-rx.c
@@ -80,6 +80,8 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	RCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);
 	__clear_bit(tid, sta->ampdu_mlme.agg_session_valid);
 
+	params.ndp = tid_rx ? tid_rx->ndp : false;
+
 	ht_dbg(sta->sdata,
 	       "Rx BA session stop requested for %pM tid %u %s reason: %d\n",
 	       sta->sta.addr, tid,
@@ -94,7 +96,7 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 	/* check if this is a self generated aggregation halt */
 	if (initiator == WLAN_BACK_RECIPIENT && tx)
 		ieee80211_send_delba(sta->sdata, sta->sta.addr,
-				     tid, WLAN_BACK_RECIPIENT, reason);
+				     tid, params.ndp, WLAN_BACK_RECIPIENT, reason);
 
 	/*
 	 * return here in case tid_rx is not assigned - which will happen if
@@ -190,7 +192,7 @@ static void ieee80211_add_addbaext(struct ieee80211_sub_if_data *sdata,
 
 static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 				      u8 dialog_token, u16 status, u16 policy,
-				      u16 buf_size, u16 timeout,
+				      u16 buf_size, u16 timeout, bool ndp,
 				      const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -211,7 +213,8 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;
+	mgmt->u.action.u.addba_resp.action_code = ndp ?
+			WLAN_ACTION_NDP_ADDBA_RESP : WLAN_ACTION_ADDBA_RESP;
 	mgmt->u.action.u.addba_resp.dialog_token = dialog_token;
 
 	capab = u16_encode_bits(amsdu, IEEE80211_ADDBA_PARAM_AMSDU_MASK);
@@ -232,7 +235,7 @@ static void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,
 void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 				     u8 dialog_token, u16 timeout,
 				     u16 start_seq_num, u16 ba_policy, u16 tid,
-				     u16 buf_size, bool tx, bool auto_seq,
+				     u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				     const struct ieee80211_addba_ext_ie *addbaext)
 {
 	struct ieee80211_local *local = sta->sdata->local;
@@ -243,6 +246,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 		.tid = tid,
 		.amsdu = false,
 		.timeout = timeout,
+		.ndp = ndp,
 		.ssn = start_seq_num,
 	};
 	int i, ret = -EOPNOTSUPP;
@@ -267,6 +271,11 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 		goto end;
 	}
 
+	if (ndp && !ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK)) {
+		ht_dbg(sta->sdata, "Requested NDP BA but HW does not support it\n");
+		goto end;
+	}
+
 	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
 		ht_dbg(sta->sdata,
 		       "Suspend in progress - Denying ADDBA request (%pM tid %d)\n",
@@ -398,6 +407,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 	tid_agg_rx->started = false;
 	tid_agg_rx->reorder_buf_filtered = 0;
 	tid_agg_rx->tid = tid;
+	tid_agg_rx->ndp = params.ndp;
 	tid_agg_rx->sta = sta;
 	status = WLAN_STATUS_SUCCESS;
 
@@ -419,7 +429,7 @@ void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 	if (tx)
 		ieee80211_send_addba_resp(sta, sta->sta.addr, tid,
 					  dialog_token, status, 1, buf_size,
-					  timeout, addbaext);
+					  timeout, params.ndp, addbaext);
 }
 
 void ieee80211_process_addba_request(struct ieee80211_local *local,
@@ -431,6 +441,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	struct ieee802_11_elems *elems = NULL;
 	u8 dialog_token;
 	int ies_len;
+	bool ndp_ba;
 
 	/* extract session parameters from addba request frame */
 	dialog_token = mgmt->u.action.u.addba_req.dialog_token;
@@ -442,6 +453,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	ba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;
 	tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
 	buf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;
+	ndp_ba = (mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_NDP_ADDBA_REQ);
 
 	ies_len = len - offsetof(struct ieee80211_mgmt,
 				 u.action.u.addba_req.variable);
@@ -461,7 +473,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 
 	__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,
 					start_seq_num, ba_policy, tid,
-					buf_size, true, false,
+					buf_size, true, false, ndp_ba,
 					elems ? elems->addba_ext_ie : NULL);
 free:
 	kfree(elems);
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index 1c18b862ef8c..e8b69af85e25 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -59,7 +59,7 @@
  */
 
 static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
-					 const u8 *da, u16 tid,
+					 const u8 *da, u16 tid, bool ndp,
 					 u8 dialog_token, u16 start_seq_num,
 					 u16 agg_size, u16 timeout)
 {
@@ -79,7 +79,8 @@ static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;
+	mgmt->u.action.u.addba_req.action_code = ndp ? WLAN_ACTION_NDP_ADDBA_REQ :
+			WLAN_ACTION_ADDBA_REQ;
 
 	mgmt->u.action.u.addba_req.dialog_token = dialog_token;
 	capab = IEEE80211_ADDBA_PARAM_AMSDU_MASK;
@@ -327,6 +328,8 @@ int __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
 		return -ENOENT;
 	}
 
+	params.ndp = tid_tx->ndp;
+
 	/*
 	 * if we're already stopping ignore any new requests to stop
 	 * unless we're destroying it in which case notify the driver
@@ -473,7 +476,7 @@ static void ieee80211_send_addba_with_timeout(struct sta_info *sta,
 	}
 
 	/* send AddBA request */
-	ieee80211_send_addba_request(sdata, sta->sta.addr, tid,
+	ieee80211_send_addba_request(sdata, sta->sta.addr, tid, tid_tx->ndp,
 				     tid_tx->dialog_token, tid_tx->ssn,
 				     buf_size, tid_tx->timeout);
 
@@ -491,10 +494,18 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 		.tid = tid,
 		.buf_size = 0,
 		.amsdu = false,
+		.ndp = false,
 		.timeout = 0,
 	};
 	int ret;
 
+	/* If the HW supports NDP blockacks, try to negotiate. It's the drivers responsibility to
+	 * clear .ndp if the conditions for NDP block acks are not met for this TID.
+	 * TODO: remove driver responsibility when S1G STA caps exist in mac80211
+	 */
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_NDP_BLOCKACK))
+		params.ndp = true;
+
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 
 	/*
@@ -514,7 +525,11 @@ void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
 
 	params.ssn = sta->tid_seq[tid] >> 4;
 	ret = drv_ampdu_action(local, sdata, &params);
+
+	/* driver may clear this flag if it does not want NDP for this session */
+	tid_tx->ndp = params.ndp;
 	tid_tx->ssn = params.ssn;
+
 	if (ret == IEEE80211_AMPDU_TX_START_DELAY_ADDBA) {
 		return;
 	} else if (ret == IEEE80211_AMPDU_TX_START_IMMEDIATE) {
@@ -754,6 +769,7 @@ static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 	params.buf_size = tid_tx->buf_size;
 	params.amsdu = tid_tx->amsdu;
+	params.ndp = tid_tx->ndp;
 
 	ht_dbg(sta->sdata, "Aggregation is on for %pM tid %d\n",
 	       sta->sta.addr, tid);
@@ -927,7 +943,7 @@ void ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,
 		ieee80211_agg_start_txq(sta, tid, false);
 
 	if (send_delba)
-		ieee80211_send_delba(sdata, sta->sta.addr, tid,
+		ieee80211_send_delba(sdata, sta->sta.addr, tid, tid_tx->ndp,
 			WLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);
 }
 
@@ -986,6 +1002,13 @@ void ieee80211_process_addba_resp(struct ieee80211_local *local,
 		return;
 	}
 
+	if ((tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_NDP_ADDBA_RESP) ||
+	    (!tid_tx->ndp && mgmt->u.action.u.addba_resp.action_code != WLAN_ACTION_ADDBA_RESP)) {
+		ht_dbg(sta->sdata, "wrong addBA response action code, %d ndp %d\n",
+				mgmt->u.action.u.addba_resp.action_code, tid_tx->ndp);
+		return;
+	}
+
 	del_timer_sync(&tid_tx->addba_resp_timer);
 
 	ht_dbg(sta->sdata, "switched off addBA timer for %pM tid %d\n",
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f11fd360b422..22fd7188ddf8 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -2127,6 +2127,10 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 		return err;
 	}
 
+	if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		mesh_update_mfp_flag(sdata,sta);
+	}
+
 	/*
 	 * for TDLS and for unassociated station, rate control should be
 	 * initialized only when rates are known and station is marked
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index a0710ae0e7a4..1ff676be47f6 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -499,6 +499,7 @@ static const char *hw_flag_names[] = {
 	FLAG(DISALLOW_PUNCTURING),
 	FLAG(DISALLOW_PUNCTURING_5GHZ),
 	FLAG(HANDLES_QUIET_CSA),
+	FLAG(SUPPORTS_NDP_BLOCKACK),
 	FLAG(STRICT),
 #undef FLAG
 };
diff --git a/net/mac80211/ht.c b/net/mac80211/ht.c
index 1c2b7dd8976a..de424fe3690e 100644
--- a/net/mac80211/ht.c
+++ b/net/mac80211/ht.c
@@ -379,7 +379,7 @@ void ieee80211_ba_session_work(struct wiphy *wiphy, struct wiphy_work *work)
 				       sta->ampdu_mlme.tid_rx_manage_offl))
 			__ieee80211_start_rx_ba_session(sta, 0, 0, 0, 1, tid,
 							IEEE80211_MAX_AMPDU_BUF_HT,
-							false, true, NULL);
+							false, true, false, NULL);
 
 		if (test_and_clear_bit(tid + IEEE80211_NUM_TIDS,
 				       sta->ampdu_mlme.tid_rx_manage_offl))
@@ -454,7 +454,7 @@ void ieee80211_ba_session_work(struct wiphy *wiphy, struct wiphy_work *work)
 }
 
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code)
 {
 	struct ieee80211_local *local = sdata->local;
@@ -472,7 +472,7 @@ void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
 	skb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));
 
 	mgmt->u.action.category = WLAN_CATEGORY_BACK;
-	mgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;
+	mgmt->u.action.u.delba.action_code = ndp ? WLAN_ACTION_NDP_DELBA : WLAN_ACTION_DELBA;
 	params = (u16)(initiator << 11); 	/* bit 11 initiator */
 	params |= (u16)(tid << 12); 		/* bit 15:12 TID number */
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index bfe0514efca3..251d7d1e6812 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -798,6 +798,10 @@ struct ieee80211_if_mesh {
 	int mesh_paths_generation;
 	int mpp_paths_generation;
 	struct mesh_tx_cache tx_cache;
+	 enum {
+		IEEE80211_MESH_MFP_DISABLED,
+		IEEE80211_MESH_MFP_ENABLED,
+	} mfp; /* management frame protection */
 };
 
 #ifdef CONFIG_MAC80211_MESH
@@ -2108,7 +2112,7 @@ bool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,
 				       const struct ieee80211_ht_cap *ht_cap_ie,
 				       struct link_sta_info *link_sta);
 void ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,
-			  const u8 *da, u16 tid,
+			  const u8 *da, u16 tid, bool ndp,
 			  u16 initiator, u16 reason_code);
 int ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
 			       enum ieee80211_smps_mode smps, const u8 *da,
@@ -2121,7 +2125,7 @@ void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
 void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 				     u8 dialog_token, u16 timeout,
 				     u16 start_seq_num, u16 ba_policy, u16 tid,
-				     u16 buf_size, bool tx, bool auto_seq,
+				     u16 buf_size, bool tx, bool auto_seq, bool ndp,
 				     const struct ieee80211_addba_ext_ie *addbaext);
 void ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,
 					 enum ieee80211_agg_stop_reason reason);
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 7e1e561ef76c..0b98addfcdaa 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1495,14 +1495,17 @@ static void ieee80211_iface_process_skb(struct ieee80211_local *local,
 		if (sta) {
 			switch (mgmt->u.action.u.addba_req.action_code) {
 			case WLAN_ACTION_ADDBA_REQ:
+			case WLAN_ACTION_NDP_ADDBA_REQ:
 				ieee80211_process_addba_request(local, sta,
 								mgmt, len);
 				break;
 			case WLAN_ACTION_ADDBA_RESP:
+			case WLAN_ACTION_NDP_ADDBA_RESP:
 				ieee80211_process_addba_resp(local, sta,
 							     mgmt, len);
 				break;
 			case WLAN_ACTION_DELBA:
+			case WLAN_ACTION_NDP_DELBA:
 				ieee80211_process_delba(sdata, sta,
 							mgmt, len);
 				break;
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 50eb1d8cd43d..73a1650417f2 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -1710,6 +1710,19 @@ void ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
 	}
 }
 
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	if (test_sta_flag(sta, WLAN_STA_MFP))
+	{
+		mpl_dbg(sdata,"%s: Mesh MFP Enabled\n",__func__);
+		ifmsh->mfp = IEEE80211_MESH_MFP_ENABLED;
+	} else {
+		mpl_dbg(sdata,"%s: Mesh MFP Disabled\n",__func__);
+		ifmsh->mfp = IEEE80211_MESH_MFP_DISABLED;
+	}
+}
+
 static void mesh_bss_info_changed(struct ieee80211_sub_if_data *sdata)
 {
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
diff --git a/net/mac80211/mesh.h b/net/mac80211/mesh.h
index 3f9664e4e00c..bc0c23423cc0 100644
--- a/net/mac80211/mesh.h
+++ b/net/mac80211/mesh.h
@@ -229,7 +229,13 @@ struct mesh_rmc {
 #define MESH_MAX_MPATHS		1024
 
 /* Number of frames buffered per destination for unresolved destinations */
-#define MESH_FRAME_QUEUE_LEN	10
+#define MESH_FRAME_QUEUE_LEN	50
+
+/* Best metric for single hop HaLow link */
+#define BEST_SINGLE_HOP_METRIC_HALOW  253
+
+/* Max path discovery timeout in msecs */
+#define MESH_MAX_MPATH_DISCOVERY_TIMEOUT      2000
 
 /* Public interfaces */
 /* Various */
@@ -418,12 +424,15 @@ static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata);
 void mesh_sync_adjust_tsf(struct ieee80211_sub_if_data *sdata);
 void ieee80211s_stop(void);
+void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta);
 #else
 static inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)
 { return false; }
 static inline void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)
 {}
 static inline void ieee80211s_stop(void) {}
+static inline void mesh_update_mfp_flag(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{}
 #endif
 
 #endif /* IEEE80211S_H */
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index 2922a9fec950..1c2c03602175 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -132,13 +132,13 @@ static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
 
 	switch (action) {
 	case MPATH_PREQ:
-		mhwmp_dbg(sdata, "sending PREQ to %pM\n", target);
+		mhwmp_dbg(sdata, "sending PREQ to %pM da:%pM\n", target, da);
 		ie_len = 37;
 		pos = skb_put(skb, 2 + ie_len);
 		*pos++ = WLAN_EID_PREQ;
 		break;
 	case MPATH_PREP:
-		mhwmp_dbg(sdata, "sending PREP to %pM\n", orig_addr);
+		mhwmp_dbg(sdata, "sending PREP to %pM da:%pM\n", orig_addr, da);
 		ie_len = 31;
 		pos = skb_put(skb, 2 + ie_len);
 		*pos++ = WLAN_EID_PREP;
@@ -190,6 +190,8 @@ static int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,
 		pos += 4;
 	}
 
+	if (sdata->u.mesh.mfp == IEEE80211_MESH_MFP_DISABLED)
+		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
 	ieee80211_tx_skb(sdata, skb);
 	return 0;
 }
@@ -304,6 +306,17 @@ void ieee80211s_update_metric(struct ieee80211_local *local,
 
 	failed = !(txinfo->flags & IEEE80211_TX_STAT_ACK);
 
+	if (!ewma_mesh_fail_avg_read(&sta->mesh->fail_avg)) {
+		/* If the average value in mesh metrics calculation
+		 * has been rounded to 0 (success), this resets it to
+		 * the smallest nonzero value (similarly to the initialization)
+		 * to avoid a case where a single failure would result in
+		 * an average value that goes beyond the value
+		 * of 95 (Link Failure Threshold)
+		 */
+		ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
+	}
+
 	/* moving average, scaled to 100.
 	 * feed failure as 100 and success as 0
 	 */
@@ -367,6 +380,32 @@ u32 airtime_link_metric_get(struct ieee80211_local *local,
 	return (u32)result;
 }
 
+void ieee80211_mpath_dump(struct ieee80211_sub_if_data *sdata)
+{
+    struct mesh_path *mpath;
+    u32 exp_time = 0;
+    int idx = 0;
+
+    mhwmp_dbg(sdata, "************** mpath Table **************\n");
+    while (mpath = mesh_path_lookup_by_idx(sdata, idx)) {
+        if (time_before(jiffies, mpath->exp_time))
+            exp_time = jiffies_to_msecs(mpath->exp_time - jiffies);
+        else
+            exp_time = 0;
+
+        mhwmp_dbg(sdata, "idx:%d dst:%pM next_hop:%pM metric:%d hops:%d exp_time:%d flags:%x\n",
+            idx,
+            mpath->dst,
+            rcu_access_pointer(mpath->next_hop)->addr,
+            mpath->metric,
+            mpath->hop_count,
+            exp_time,
+            mpath->flags);
+
+        idx++;
+    }
+}
+
 /* Check that the first metric is at least 10% better than the second one */
 static bool is_metric_better(u32 x, u32 y)
 {
@@ -397,6 +436,7 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	struct mesh_path *mpath;
 	struct sta_info *sta;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
 	bool fresh_info;
 	const u8 *orig_addr, *ta;
 	u32 orig_sn, orig_metric;
@@ -405,6 +445,7 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 	bool flush_mpath = false;
 	bool process = true;
 	u8 hopcount;
+	bool new_path = false;
 
 	rcu_read_lock();
 	sta = sta_info_get(sdata, mgmt->sa);
@@ -456,22 +497,26 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 		mpath = mesh_path_lookup(sdata, orig_addr);
 		if (mpath) {
 			spin_lock_bh(&mpath->state_lock);
+			mhwmp_dbg(sdata, "%s from:%pM->%pM new_metric:%d metric:%d hops:%d \n",
+				action ? "PREP" : "PREQ", orig_addr, mgmt->sa, new_metric,
+				mpath->metric, hopcount);
 			if (mpath->flags & MESH_PATH_FIXED)
 				fresh_info = false;
-			else if ((mpath->flags & MESH_PATH_ACTIVE) &&
+			if ((mpath->flags & MESH_PATH_ACTIVE) &&
 			    (mpath->flags & MESH_PATH_SN_VALID)) {
 				if (SN_GT(mpath->sn, orig_sn) ||
-				    (mpath->sn == orig_sn &&
-				     (rcu_access_pointer(mpath->next_hop) !=
-						      sta ?
-					      !is_metric_better(new_metric, mpath->metric) :
-					      new_metric >= mpath->metric))) {
-					process = false;
-					fresh_info = false;
+					(mpath->metric &&
+					(rcu_access_pointer(mpath->next_hop) != sta) &&
+					(mult_frac(new_metric, 10, 9) >= mpath->metric))) {
+					 mhwmp_dbg(sdata, "skip long path orig:%pM sa:%pM \n",
+						orig_addr, mgmt->sa);
+					 process = false;
+					 fresh_info = false;
 				}
 			} else if (!(mpath->flags & MESH_PATH_ACTIVE)) {
 				bool have_sn, newer_sn, bounced;
 
+				mhwmp_dbg(sdata, "expired path for %pM flags %x \n", orig_addr, mpath->flags);
 				have_sn = mpath->flags & MESH_PATH_SN_VALID;
 				newer_sn = have_sn && SN_GT(orig_sn, mpath->sn);
 				bounced = have_sn &&
@@ -485,7 +530,13 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 					/* if SN is way different than what
 					 * we had then assume the other side
 					 * rebooted or restarted */;
+				} else if (have_sn && mpath->metric && (new_metric <= mpath->metric)) {
+					/* Accept frame */
 				} else {
+					mhwmp_dbg(sdata, "dropping %s from:%pM->%pM expired path"
+						"have_sn:%d new:%d bounce:%d delta:%d new_metric:%d metric:%d\n",
+						action ? "PREP" : "PREQ", orig_addr, mgmt->sa, have_sn, newer_sn,
+						bounced, SN_DELTA(orig_sn, mpath->sn), new_metric, mpath->metric);
 					process = false;
 					fresh_info = false;
 				}
@@ -497,6 +548,9 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 				return 0;
 			}
 			spin_lock_bh(&mpath->state_lock);
+			new_path = true;
+			mhwmp_dbg(sdata, "New Dst node path %pM with %s\n",
+			 orig_addr, action ? "PREP" : "PREQ");
 		}
 
 		if (fresh_info) {
@@ -508,6 +562,14 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 			mpath->flags |= MESH_PATH_SN_VALID;
 			mpath->metric = new_metric;
 			mpath->sn = orig_sn;
+			/* re-confirm if new paths are the optimal */
+			if (new_path) {
+				/* Overwrite expiry time with smaller value to re-confirm
+				 * if new path is optimal, with path refresh operation */
+				unsigned long refresh_time_jif =
+					msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time);
+				exp_time = refresh_time_jif + jiffies;
+			}
 			mpath->exp_time = time_after(mpath->exp_time, exp_time)
 					  ?  mpath->exp_time : exp_time;
 			mpath->hop_count = hopcount;
@@ -518,6 +580,11 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 			ewma_mesh_fail_avg_init(&sta->mesh->fail_avg);
 			/* init it at a low value - 0 start is tricky */
 			ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
+			mhwmp_dbg(sdata, "updated path %pM with %s\n",
+				mpath->dst, action ? "PREP" : "PREQ");
+#ifdef CONFIG_MAC80211_MHWMP_DEBUG
+			ieee80211_mpath_dump(sdata);
+#endif
 			mesh_path_tx_pending(mpath);
 			/* draft says preq_id should be saved to, but there does
 			 * not seem to be any use for it, skipping by now
@@ -527,8 +594,11 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 	}
 
 	/* Update and check transmitter routing info */
+	new_path = false;
+	exp_time = TU_TO_EXP_TIME(orig_lifetime);
 	ta = mgmt->sa;
-	if (ether_addr_equal(orig_addr, ta))
+	if (ether_addr_equal(orig_addr, ta) ||
+        (ifmsh->mshcfg.dot11MeshNolearn))
 		fresh_info = false;
 	else {
 		fresh_info = true;
@@ -543,11 +613,14 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 				       last_hop_metric > mpath->metric))))
 				fresh_info = false;
 		} else {
+			new_path = true;
 			mpath = mesh_path_add(sdata, ta);
 			if (IS_ERR(mpath)) {
 				rcu_read_unlock();
 				return 0;
 			}
+			mhwmp_dbg(sdata, "New Tx node path %pM with %s\n",
+			 ta, action ? "PREP" : "PREQ");
 			spin_lock_bh(&mpath->state_lock);
 		}
 
@@ -558,6 +631,13 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 			}
 			mesh_path_assign_nexthop(mpath, sta);
 			mpath->metric = last_hop_metric;
+			if (new_path) {
+				/* Overwrite expiry time with smaller value to re-confirm
+				 * if new path is optimal, with path refresh operation */
+				unsigned long refresh_time_jif =
+					msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time);
+				exp_time = refresh_time_jif + jiffies;
+			}
 			mpath->exp_time = time_after(mpath->exp_time, exp_time)
 					  ?  mpath->exp_time : exp_time;
 			mpath->hop_count = 1;
@@ -568,6 +648,11 @@ static u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,
 			ewma_mesh_fail_avg_init(&sta->mesh->fail_avg);
 			/* init it at a low value - 0 start is tricky */
 			ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
+			mhwmp_dbg(sdata, "updated Tx node path %pM with %s\n",
+				ta, action ? "PREP" : "PREQ");
+#ifdef CONFIG_MAC80211_MHWMP_DEBUG
+			ieee80211_mpath_dump(sdata);
+#endif
 			mesh_path_tx_pending(mpath);
 		} else
 			spin_unlock_bh(&mpath->state_lock);
@@ -605,7 +690,7 @@ static void hwmp_preq_frame_process(struct ieee80211_sub_if_data *sdata,
 	mhwmp_dbg(sdata, "received PREQ from %pM\n", orig_addr);
 
 	if (ether_addr_equal(target_addr, sdata->vif.addr)) {
-		mhwmp_dbg(sdata, "PREQ is for us\n");
+		mhwmp_dbg(sdata, "PREQ is for us from %pM\n", mgmt->sa);
 		forward = false;
 		reply = true;
 		target_metric = 0;
@@ -810,6 +895,10 @@ static void hwmp_perr_frame_process(struct ieee80211_sub_if_data *sdata,
 		    !(mpath->flags & MESH_PATH_FIXED) &&
 		    (!(mpath->flags & MESH_PATH_SN_VALID) ||
 		    SN_GT(target_sn, mpath->sn)  || target_sn == 0)) {
+			mhwmp_dbg(sdata, "PERR deactivate path for :%pM flags:%x exp_time:%d"
+				"hops:%d metric:%d Queue_len:%d\n",
+				mpath->dst, mpath->flags, jiffies_to_msecs(mpath->exp_time - jiffies),
+				mpath->hop_count, mpath->metric, skb_queue_len(&mpath->frame_queue));
 			mpath->flags &= ~MESH_PATH_ACTIVE;
 			if (target_sn != 0)
 				mpath->sn = target_sn;
@@ -1095,6 +1184,7 @@ void mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata)
 			mpath->flags |= MESH_PATH_RESOLVING;
 			mpath->discovery_retries = 0;
 			mpath->discovery_timeout = disc_timeout_jiff(sdata);
+			mhwmp_dbg(sdata, "New start discovery for %pM \n", mpath->dst);
 		}
 	} else if (!(mpath->flags & MESH_PATH_RESOLVING) ||
 			mpath->flags & MESH_PATH_RESOLVED) {
@@ -1175,6 +1265,7 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 	/* no nexthop found, start resolving */
 	mpath = mesh_path_lookup(sdata, target_addr);
 	if (!mpath) {
+		mhwmp_dbg(sdata, "no mpath found for %pM, add one \n", target_addr);
 		mpath = mesh_path_add(sdata, target_addr);
 		if (IS_ERR(mpath)) {
 			mesh_path_discard_frame(sdata, skb);
@@ -1182,13 +1273,16 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 		}
 	}
 
-	if (!(mpath->flags & MESH_PATH_RESOLVING) &&
-	    mesh_path_sel_is_hwmp(sdata))
-		mesh_queue_preq(mpath, PREQ_Q_F_START);
+	if (!(mpath->flags & (MESH_PATH_RESOLVING | MESH_PATH_REQ_QUEUED)) &&
+	    mesh_path_sel_is_hwmp(sdata)) {
+		mhwmp_dbg(sdata, "no nexthop found for %pM, start resolving \n", target_addr);
+		mesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);
+	}
 
-	if (skb_queue_len(&mpath->frame_queue) >= MESH_FRAME_QUEUE_LEN)
+	if (skb_queue_len(&mpath->frame_queue) >= MESH_FRAME_QUEUE_LEN) {
+        IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh, dropped_frames_no_route);
 		skb_to_free = skb_dequeue(&mpath->frame_queue);
-
+	}
 	info->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;
 	ieee80211_set_qos_hdr(sdata, skb);
 	skb_queue_tail(&mpath->frame_queue, skb);
@@ -1232,18 +1326,37 @@ static int mesh_nexthop_lookup_nolearn(struct ieee80211_sub_if_data *sdata,
 	return 0;
 }
 
+/**
+ * Checks if the given mpath is optimal.
+ *
+ * @param mpath: Pointer to the mpath structure containing path data.
+ * @return true if the mpath is optimal, false otherwise.
+ */
+bool hwmp_is_mpath_optimal(struct mesh_path *mpath)
+{
+    /* Check if the metric is within acceptable limits */
+    return (mpath->metric <= (mpath->hop_count * BEST_SINGLE_HOP_METRIC_HALOW));
+}
+
 void mesh_path_refresh(struct ieee80211_sub_if_data *sdata,
 		       struct mesh_path *mpath, const u8 *addr)
 {
-	if (mpath->flags & (MESH_PATH_REQ_QUEUED | MESH_PATH_FIXED |
-			    MESH_PATH_RESOLVING))
+	unsigned long refresh_time_jif = msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time);
+
+	if ((mpath->flags & (MESH_PATH_REQ_QUEUED | MESH_PATH_FIXED | MESH_PATH_RESOLVING)))
 		return;
 
-	if (time_after(jiffies,
-		       mpath->exp_time -
-		       msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&
-	    (!addr || ether_addr_equal(sdata->vif.addr, addr)))
+	if(time_after(jiffies, (mpath->exp_time - refresh_time_jif)) &&
+	   (!addr || ether_addr_equal(sdata->vif.addr, addr)))
 		mesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);
+
+	if (hwmp_is_mpath_optimal(mpath)) {
+		/* Refresh path, if path is being actively used & optimal */
+		unsigned long exp_time =
+			msecs_to_jiffies(sdata->u.mesh.mshcfg.dot11MeshHWMPactivePathTimeout);
+		mpath->exp_time = time_after(mpath->exp_time, (exp_time + jiffies)) ?
+			mpath->exp_time : (exp_time + jiffies);
+	}
 }
 
 /**
@@ -1304,10 +1417,11 @@ void mesh_path_timer(struct timer_list *t)
 		spin_unlock_bh(&mpath->state_lock);
 	} else if (mpath->discovery_retries < max_preq_retries(sdata)) {
 		++mpath->discovery_retries;
-		mpath->discovery_timeout *= 2;
+		mpath->discovery_timeout = min(mpath->discovery_timeout * 2,
+			msecs_to_jiffies(MESH_MAX_MPATH_DISCOVERY_TIMEOUT));
 		mpath->flags &= ~MESH_PATH_REQ_QUEUED;
 		spin_unlock_bh(&mpath->state_lock);
-		mesh_queue_preq(mpath, 0);
+		mesh_queue_preq(mpath, PREQ_Q_F_REFRESH);
 	} else {
 		mpath->flags &= ~(MESH_PATH_RESOLVING |
 				  MESH_PATH_RESOLVED |
diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c
index 30c0d89203af..5d4577bdbf3f 100644
--- a/net/mac80211/mesh_pathtbl.c
+++ b/net/mac80211/mesh_pathtbl.c
@@ -779,6 +779,12 @@ void mesh_plink_broken(struct sta_info *sta)
 		if (rcu_access_pointer(mpath->next_hop) == sta &&
 		    mpath->flags & MESH_PATH_ACTIVE &&
 		    !(mpath->flags & MESH_PATH_FIXED)) {
+			mhwmp_dbg(sdata, "Broken path for :%pM flags:%x exp_time:%d"
+				"hops:%d metric:%d Queue_len:%d\n",
+				mpath->dst, mpath->flags,
+				jiffies_to_msecs(mpath->exp_time - jiffies),
+				mpath->hop_count, mpath->metric,
+				skb_queue_len(&mpath->frame_queue));
 			spin_lock_bh(&mpath->state_lock);
 			mpath->flags &= ~MESH_PATH_ACTIVE;
 			++mpath->sn;
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index ad0d040569dc..1d1dc0e76a5f 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -71,6 +71,14 @@ module_param(beacon_loss_count, int, 0644);
 MODULE_PARM_DESC(beacon_loss_count,
 		 "Number of beacon intervals before we decide beacon was lost.");
 
+/*
+ * Number of beacon intervals to wait for a beacon at association.
+ */
+static int beacon_wait_count = 1;
+module_param(beacon_wait_count, int, 0644);
+MODULE_PARM_DESC(beacon_wait_count,
+		 "Number of beacon intervals to wait for a beacon at association.");
+
 /*
  * Time the connection can be idle before we probe
  * it to see if we can still talk to the AP.
@@ -2615,6 +2623,7 @@ ieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,
 	now = jiffies;
 	link->u.mgd.csa.time = now +
 			       TU_TO_JIFFIES((max_t(int, csa_ie.count, 1) - 1) *
+					     sdata->vif.bss_conf.dtim_period *
 					     link->conf->beacon_int);
 
 	if (ieee80211_vif_link_active(&sdata->vif, link->link_id) &&
@@ -9125,11 +9134,12 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 		if (!beacon_ies) {
 			/*
 			 * Wait up to one beacon interval ...
-			 * should this be more if we miss one?
+			 * Beacon periods to wait can be set via modparam
 			 */
 			sdata_info(sdata, "waiting for beacon from %pM\n",
 				   link->u.mgd.bssid);
-			assoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);
+			assoc_data->timeout = TU_TO_EXP_TIME(beacon_wait_count *
+				req->bss->beacon_interval);
 			assoc_data->timeout_started = true;
 			assoc_data->need_beacon = true;
 		}
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 8e1fbdd3bff1..cc1025279374 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1374,7 +1374,7 @@ static void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx,
 		if (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&
 		    !test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 		goto dont_reorder;
@@ -2978,19 +2978,13 @@ ieee80211_rx_mesh_data(struct ieee80211_sub_if_data *sdata, struct sta_info *sta
 		memcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);
 		/* update power mode indication when forwarding */
 		ieee80211_mps_set_frame_flags(sdata, NULL, fwd_hdr);
-	} else if (!mesh_nexthop_lookup(sdata, fwd_skb)) {
+	}
+	else if (!mesh_nexthop_resolve(sdata, fwd_skb)) {
 		/* mesh power mode flags updated in mesh_nexthop_lookup */
 		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);
 	} else {
-		/* unable to resolve next hop */
-		if (sta)
-			mesh_path_error_tx(sdata, ifmsh->mshcfg.element_ttl,
-					   hdr.addr3, 0,
-					   WLAN_REASON_MESH_PATH_NOFORWARD,
-					   sta->sta.addr);
-		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_no_route);
-		kfree_skb(fwd_skb);
-		goto rx_accept;
+		/* skb queued: don't free */
+		return RX_DROP_MONITOR;
 	}
 
 	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
@@ -3246,6 +3240,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 {
 	struct sk_buff *skb = rx->skb;
 	struct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;
+	struct ieee80211_mgmt *back = (struct ieee80211_mgmt *)skb->data;
 	struct tid_ampdu_rx *tid_agg_rx;
 	u16 start_seq_num;
 	u16 tid;
@@ -3272,7 +3267,7 @@ ieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)
 
 		if (!test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&
 		    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))
-			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,
+			ieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid, false,
 					     WLAN_BACK_RECIPIENT,
 					     WLAN_REASON_QSTA_REQUIRE_SETUP);
 
@@ -3678,16 +3673,19 @@ ieee80211_rx_h_action(struct ieee80211_rx_data *rx)
 
 		switch (mgmt->u.action.u.addba_req.action_code) {
 		case WLAN_ACTION_ADDBA_REQ:
+		case WLAN_ACTION_NDP_ADDBA_REQ:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_req)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_ADDBA_RESP:
+		case WLAN_ACTION_NDP_ADDBA_RESP:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.addba_resp)))
 				goto invalid;
 			break;
 		case WLAN_ACTION_DELBA:
+		case WLAN_ACTION_NDP_DELBA:
 			if (len < (IEEE80211_MIN_ACTION_SIZE +
 				   sizeof(mgmt->u.action.u.delba)))
 				goto invalid;
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index 9195d5a2de0a..877d688891da 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -171,6 +171,7 @@ struct sta_info;
  * @bar_pending: BAR needs to be re-sent
  * @amsdu: support A-MSDU withing A-MDPU
  * @ssn: starting sequence number of the session
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -199,6 +200,7 @@ struct tid_ampdu_tx {
 	u16 failed_bar_ssn;
 	bool bar_pending;
 	bool amsdu;
+	bool ndp;
 	u8 tid;
 };
 
@@ -226,6 +228,7 @@ struct tid_ampdu_tx {
  *	and ssn.
  * @removed: this session is removed (but might have been found due to RCU)
  * @started: this session has started (head ssn or higher was received)
+ * @ndp: this session is using NDP block ACKs
  *
  * This structure's lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
@@ -253,7 +256,8 @@ struct tid_ampdu_rx {
 	u8 tid;
 	u8 auto_seq:1,
 	   removed:1,
-	   started:1;
+	   started:1,
+	   ndp:1;
 };
 
 /**
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 0ff8b56f5807..6a7af4ee2426 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -4307,6 +4307,12 @@ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 		if (fast_tx &&
 		    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))
 			goto out;
+	} else if (ieee80211_vif_is_mesh(&sdata->vif)) {
+		/* For mesh interface, sta is determined in ieee80211_tx_prepare after building
+		 * mesh header. Update tx pacing shift here, otherwise it affects TCP throughput as
+		 * there won't be enough packets to aggregate.
+		 */
+		sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
 	}
 
 	/* the frame could be fragmented, software-encrypted, and other
@@ -5032,11 +5038,11 @@ static void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,
 
 static u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)
 {
-	beacon->cntdwn_current_counter--;
-
 	/* the counter should never reach 0 */
 	WARN_ON_ONCE(!beacon->cntdwn_current_counter);
 
+	beacon->cntdwn_current_counter--;
+
 	return beacon->cntdwn_current_counter;
 }
 
@@ -5306,7 +5312,13 @@ ieee80211_beacon_get_ap(struct ieee80211_hw *hw,
 	u16 csa_off_base = 0;
 	int mbssid_len;
 
-	if (beacon->cntdwn_counter_offsets[0]) {
+	bool short_beacon = (vif->bss_conf.dtim_period > 1);
+
+	if (ap->ps.dtim_count > 0)
+		short_beacon = ((ap->ps.dtim_count-1) != 0);
+
+	 /* Do not count channel switch count for short beacons */
+	if (beacon->cntdwn_counter_offsets[0] && !short_beacon) {
 		if (!is_template)
 			ieee80211_beacon_update_cntdwn(vif, link->link_id);
 
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 1ce8fff2a28a..9304bd2f7f66 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1439,8 +1439,8 @@ void cfg80211_init_wdev(struct wireless_dev *wdev)
 	wdev->ps_timeout = -1;
 
 	if ((wdev->iftype == NL80211_IFTYPE_STATION ||
-	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
-	     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
+	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&
+        !wdev->use_4addr)
 		wdev->netdev->priv_flags |= IFF_DONT_BRIDGE;
 
 	INIT_WORK(&wdev->disconnect_wk, cfg80211_autodisconnect_wk);
diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 2c6654075ca9..fe8d42119a3c 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -18,7 +18,7 @@
 #define MESH_CONF_T 		100
 #define MESH_HOLD_T 		100
 
-#define MESH_PATH_TIMEOUT	5000
+#define MESH_PATH_TIMEOUT	50000
 #define MESH_RANN_INTERVAL      5000
 #define MESH_PATH_TO_ROOT_TIMEOUT      6000
 #define MESH_ROOT_INTERVAL     5000
@@ -31,22 +31,22 @@
  */
 #define MESH_PREQ_MIN_INT	10
 #define MESH_PERR_MIN_INT	100
-#define MESH_DIAM_TRAVERSAL_TIME 50
+#define MESH_DIAM_TRAVERSAL_TIME 200
 
-#define MESH_RSSI_THRESHOLD	0
+#define MESH_RSSI_THRESHOLD	-85
 
 /*
  * A path will be refreshed if it is used PATH_REFRESH_TIME milliseconds
  * before timing out.  This way it will remain ACTIVE and no data frames
  * will be unnecessarily held in the pending queue.
  */
-#define MESH_PATH_REFRESH_TIME			1000
+#define MESH_PATH_REFRESH_TIME			10000
 #define MESH_MIN_DISCOVERY_TIMEOUT (2 * MESH_DIAM_TRAVERSAL_TIME)
 
 /* Default maximum number of established plinks per interface */
 #define MESH_MAX_ESTAB_PLINKS	32
 
-#define MESH_MAX_PREQ_RETRIES	4
+#define MESH_MAX_PREQ_RETRIES	6
 
 #define MESH_SYNC_NEIGHBOR_OFFSET_MAX 50
 
@@ -82,7 +82,7 @@ const struct mesh_config default_mesh_config = {
 	.power_mode = NL80211_MESH_POWER_ACTIVE,
 	.dot11MeshAwakeWindowDuration = MESH_DEFAULT_AWAKE_WINDOW,
 	.plink_timeout = MESH_DEFAULT_PLINK_TIMEOUT,
-	.dot11MeshNolearn = false,
+	.dot11MeshNolearn = true,
 };
 
 const struct mesh_setup default_mesh_setup = {
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index ecfceddce00f..bd62aa432b03 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1122,6 +1122,9 @@ static int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,
 	if ((chan->flags & IEEE80211_CHAN_DISABLED) &&
 	    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))
 		goto nla_put_failure;
+	if ((chan->flags & IEEE80211_CHAN_IGNORE) &&
+	    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))
+		goto nla_put_failure;
 	if (chan->flags & IEEE80211_CHAN_NO_IR) {
 		if (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))
 			goto nla_put_failure;
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 18585b1416c6..78b6bfa515f7 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -1230,7 +1230,6 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
 			fallthrough;
 		case NL80211_IFTYPE_OCB:
 		case NL80211_IFTYPE_P2P_CLIENT:
-		case NL80211_IFTYPE_ADHOC:
 			dev->priv_flags |= IFF_DONT_BRIDGE;
 			break;
 		case NL80211_IFTYPE_P2P_GO:
